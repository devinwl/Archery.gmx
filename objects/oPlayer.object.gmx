<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oParEntity</parentName>
  <maskName>sprPlayerMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Inherit oParEntity variables
event_inherited();

// Constants
enum KeyList {
    KEY_RIGHT = vk_right,
    KEY_UP = vk_up,
    KEY_LEFT = vk_left,
    KEY_DOWN = vk_down,
    KEY_SHOOT = mb_left,
    KEY_ROLL = ord('Z')
}

// Movement ///////////////////////////////////////////////////////////////////

// Multiplier
groundFric  = 0.6;
vxMax       = 4.0;
vyMax       = 4.0;

maxEndurance = 100;
endurance = maxEndurance;
enduranceRecharging = false;

shotHeldTimer = 0;
shotHeldTimerThresh = 20;

// Misc ///////////////////////////////////////////////////////////////////////

// Relative collision checks
//cLeft  = place_meeting(x - 1, y, oParSolid);
//cRight = place_meeting(x + 1, y, oParSolid);

// State information
/*
PLAYER_STATE_IDLE = 1;
PLAYER_STATE_RUNNING = 2;
PLAYER_STATE_JUMP_BEGIN = 3;
PLAYER_STATE_JUMP_MID = 4;
PLAYER_STATE_JUMP_FALLING = 5;
PLAYER_STATE_CLINGING = 6;
PLAYER_STATE_STUNNED = 7;
PLAYER_STATE_FLYING = 8;
PLAYER_STATE_ATTACHED = 9;
PLAYER_STATE_HURT = 10;
PLAYER_STATE_JUMP_INIT = 11;

playerState = PLAYER_STATE_IDLE;

// Animation stuff
SPR_PLAYER_IDLE = sprPlayer1;
SPR_IDLE_SPEED = 0.10;

SPR_PLAYER_RUN = sprPlayer1Run;
SPR_RUNNING_SPEED = 0.2;

SPR_PLAYER_JUMP = sprPlayer1Jump;
SPR_JUMPING_SPEED = 0;

SPR_PLAYER_CLINGING = sprPlayer1Cling;
SPR_CLINGING_SPEED = 0;

SPR_PLAYER_HURT = sprPlayer1Hurt;
SPR_PLAYER_HURT_SPEED = 0;

SPR_PLAYER_STUNNED = sprPlayer1Stunned;
SPR_PLAYER_STUNNED_SPEED = 0;

SPR_PLAYER_FLYING = sprPlayer1Flying;
SPR_PLAYER_FLYING_SPEED = 0;
*/

xScale = 1;
yScale = 1;

/*

// Melee attack stuff, move later
attackTimer = 0;
attackMaxFrames = sprite_get_number(sprPlayer1MeleeAttack) / 0.3;

PLAYER_STATE_ATTACKING = 99;
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Input //////////////////////////////////////////////////////////////////////

var kLeft, kRight, kUp, kDown, kJump, kJumpRelease, tempAccel, tempFric;
var kRoll;

// Only return keys as true if the player can move
// Otherwise just apply gravity as normal
kLeft        = keyboard_check(KeyList.KEY_LEFT);
kRight       = keyboard_check(KeyList.KEY_RIGHT);
kUp          = keyboard_check(KeyList.KEY_UP);
kDown        = keyboard_check(KeyList.KEY_DOWN);
kShootHeld       = mouse_check_button(KeyList.KEY_SHOOT);
kShootRelease       = mouse_check_button_released(KeyList.KEY_SHOOT);
kRoll        = keyboard_check_pressed(KeyList.KEY_ROLL);

var maxSpeedX, maxSpeedY;
var speedMod = 1;
if(kShootHeld) {
    speedMod = 1.5;
    shotHeldTimer += 1;
}

if( (kUp || kDown) &amp;&amp; (kLeft || kRight)) {
    maxSpeedX = (vxMax - 1) / speedMod;
    maxSpeedY = (vyMax - 1) / speedMod;
}
else {
    maxSpeedX = (vxMax) / speedMod;
    maxSpeedY = (vyMax - 1) / speedMod;
}


// Left 
if (kLeft &amp;&amp; !kRight) {
    // Apply acceleration left
    if (vx &gt; 0)
        vx = Approach(vx, 0, groundFric);   
    vx = Approach(vx, -maxSpeedX, groundFric);
}

// Right 
if (kRight &amp;&amp; !kLeft) {
    // Apply acceleration right
    if (vx &lt; 0)
        vx = Approach(vx, 0, groundFric);   
    vx = Approach(vx, maxSpeedX, groundFric);
}

// Up
if (kUp &amp;&amp; !kDown) {
    if (vy &gt; 0)
        vy = Approach(vy, 0, groundFric);   
    vy = Approach(vy, -maxSpeedY, groundFric);
}

// Down
if (kDown &amp;&amp; !kUp) {
    if (vy &lt; 0)
        vy = Approach(vy, 0, groundFric);   
    vy = Approach(vy, maxSpeedY, groundFric);
}

if(!kRight &amp;&amp; !kLeft) {
    vx = Approach(vx, 0, groundFric);
}

if(!kUp &amp;&amp; !kDown) {
    vy = Approach(vy, 0, groundFric);
}

if(kRoll &amp;&amp; endurance &gt; 0 &amp;&amp; !enduranceRecharging) {
    vx = 10 * sign(vx);
    vy = 10 * sign(vy);
    endurance -= 60; 
}

if(endurance &lt;= 0) {
    enduranceRecharging = true;
    endurance = 0;
}

if(endurance &lt; maxEndurance) {
    endurance += 0.2;
}

if(endurance == maxEndurance) {
    enduranceRecharging = false;
}

if(kShootRelease &amp;&amp; shotHeldTimer &gt; shotHeldTimerThresh) {
    var arrow = instance_create(x,y,oArrow);
    var dir = point_direction(x,y,mouse_x,mouse_y);
    arrow.vx = lengthdir_x(20, dir);
    arrow.vy = lengthdir_y(20, dir);
    arrow.image_angle = dir;
}

if(kShootRelease) {
    shotHeldTimer = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();
draw_text(x,y,string(vx));
draw_text(x,y+12,string(vy));
draw_text(x,y-12,string(endurance));
draw_text(x,y-24,string(shotHeldTimer));

if(enduranceRecharging)
    draw_set_colour(c_red);
else
    draw_set_color(c_black);
draw_line_width(x-16,y-32,x+16,y-32, 3);
draw_set_colour(c_green);
draw_line_width(x-16,y-32,x-16 + (32 * endurance/maxEndurance),y-32, 3);
draw_set_color(c_black);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
